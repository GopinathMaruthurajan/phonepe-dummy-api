const express = require('express');
const axios = require('axios');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');

// ==========================================
// CONFIGURATION
// ==========================================
const MAIN_PORT = 3000;  // App connects here
const SOURCE_PORT = 4000; // Database logic here
const SOURCE_URL = `http://localhost:${SOURCE_PORT}`;
const MONGO_URI = 'mongodb+srv://gopinathm_db_user:bi1gSuo0zFTO4ebG@cluster0.siwdo6l.mongodb.net/phonepe_apis';

// Connect to MongoDB
mongoose.connect(MONGO_URI)
    .then(() => console.log('âœ… Connected to MongoDB'))
    .catch(err => console.error('âŒ MongoDB Connection Error:', err));

// ==========================================
// MONGODB SCHEMAS (Database Structure)
// ==========================================

// 1. Terminal Configuration Schema
const ConfigSchema = new mongoose.Schema({
    merchantId: String,
    terminalId: String,
    integrationMode: String,
    integratedModeDisplayName: String,
    integrationMappingType: String,
    timestamp: String
});
const ConfigModel = mongoose.model('TerminalConfig', ConfigSchema);

// 2. Sale Transaction Schema
const SaleSchema = new mongoose.Schema({
    merchantId: String,
    terminalId: String,
    shortOrderId: String,
    posDeviceId: String,
    amount: Number,
    transactionId: String, // Generated by us
    createdAt: String,
    status: String,
    invoiceNumber: String // Added for CheckVoid logic
});
const SaleModel = mongoose.model('Sale', SaleSchema);

// 3. Deployment Schema
const DeploySchema = new mongoose.Schema({
    simNo: String,
    merchantId: String,
    terminalId: String,
    appId: String,
    status: String,
    workflowId: String,
    applicationNumber: String
});
const DeployModel = mongoose.model('Deployment', DeploySchema);

// 4. OTP/Verification Schema
const VerificationSchema = new mongoose.Schema({
    workflowId: String,
    appId: String,
    otp: String,
    isVerified: Boolean,
    simNo: String, // Mock data context
    latitude: String,
    longitude: String
});
const VerificationModel = mongoose.model('Verification', VerificationSchema);


// ==========================================
// PART 1: SOURCE API (Database Logic)
// Port 4000
// ==========================================
const sourceApp = express();
sourceApp.use(bodyParser.json());

// --- 1. GET CONFIG (Logic: Find in DB, or create default if missing) ---
sourceApp.post('/internal/config', async (req, res) => {
    const { mid, tid } = req.body;
    
    let config = await ConfigModel.findOne({ merchantId: mid, terminalId: tid });

    // If config doesn't exist in DB, create a default one (so the App doesn't crash)
    if (!config) {
        config = new ConfigModel({
            merchantId: mid,
            terminalId: tid,
            integrationMode: "CLOUD",
            integratedModeDisplayName: "Cloud Integration (DB)",
            integrationMappingType: "ONE_TO_ONE",
            timestamp: new Date().toISOString()
        });
        await config.save();
        console.log(`Created new config for ${mid}-${tid}`);
    }

    res.json(config);
});

// --- 2. CHECK VOID (Logic: Find sale in DB) ---
sourceApp.post('/internal/check-void', async (req, res) => {
    const { mid, tid, invoiceNumber } = req.body;

    // Try to find a sale with this invoice number
    // Note: Since we didn't save invoiceNumber in SaleRequest, we simulate checking logic
    // In a real app, you would search: await SaleModel.findOne({ invoiceNumber: invoiceNumber });
    
    const isAllowed = invoiceNumber !== "0000"; // Mock logic: block 0000

    res.json({
        merchantId: mid,
        terminalId: tid,
        transactionId: "TXN_VOID_CHECK",
        allow: isAllowed
    });
});

// --- 3. SALE REQUEST (Logic: Save to DB) ---
sourceApp.post('/internal/sale', async (req, res) => {
    // 1. Create new Sale Object from request
    const newSale = new SaleModel({
        merchantId: req.body.merchantId,
        terminalId: req.body.terminalId,
        posDeviceId: req.body.posDeviceId,
        shortOrderId: req.body.shortOrderId,
        amount: 100.00, // Hardcoded for example, usually comes from logic
        transactionId: "TXN_" + Date.now(),
        createdAt: new Date().toISOString(),
        status: "SUCCESS"
    });

    // 2. Save to MongoDB
    await newSale.save();
    console.log(`Saved Sale: ${newSale.transactionId}`);

    // 3. Return Response matching Java "SaleRequestResponse"
    res.json({
        merchantId: newSale.merchantId,
        terminalId: newSale.terminalId,
        shortOrderId: newSale.shortOrderId,
        amount: newSale.amount,
        allowedInstruments: ["CARD", "UPI"],
        autoAccept: true,
        createdAt: newSale.createdAt,
        transactionId: newSale.transactionId,
        autoAcceptWindowExpirySeconds: 60,
        pregeneratedDQRTransactionId: "DQR_" + Date.now(),
        pregeneratedCardTransactionId: "CRD_" + Date.now(),
        creationTimestamp: Date.now(),
        code: "00",
        message: "Sale Saved to DB",
        data: null
    });
});

// --- 4. DEPLOY (Logic: Save to DB) ---
sourceApp.post('/internal/deploy', async (req, res) => {
    const newDeploy = new DeployModel({
        merchantId: req.body.merchantId,
        terminalId: req.body.terminalId,
        simNo: req.body.simNo,
        appId: req.body.appId,
        status: "DEPLOYED",
        workflowId: "WF-" + Date.now(),
        applicationNumber: "APP-" + Math.floor(Math.random() * 1000)
    });

    await newDeploy.save();

    res.json({
        status: newDeploy.status,
        applicationNumber: newDeploy.applicationNumber,
        terminalId: newDeploy.terminalId,
        merchantId: newDeploy.merchantId,
        workflowId: newDeploy.workflowId
    });
});

// --- 5. OTP FLOW (Logic: Save/Update DB) ---
sourceApp.post('/internal/otp/send', async (req, res) => {
    // Create a verification record
    const verif = new VerificationModel({
        workflowId: req.body.workflowId,
        appId: req.body.appId,
        otp: "1234", // In real life, generate random
        isVerified: false
    });
    await verif.save();

    res.json({
        retryAfterInSeconds: 30,
        remainingAttempts: 3,
        totalAttempts: 3
    });
});

sourceApp.post('/internal/otp/verify', async (req, res) => {
    const { workflowId, verificationCode } = req.body;
    
    // Find in DB
    const record = await VerificationModel.findOne({ workflowId: workflowId });

    if(record) {
        // Update DB
        record.isVerified = true;
        await record.save();
    }

    res.json({
        terminalSNo: "SNO-DB-1",
        aggregatorId: "AGG-1",
        mid: "MID-DB",
        tid: "TID-DB",
        appId: req.body.appId,
        otp: verificationCode,
        simNo: "SIM-DB",
        latitude: 0.0,
        longitude: 0.0
    });
});

sourceApp.listen(SOURCE_PORT, () => {
    console.log(`ðŸ”Œ Source API (MongoDB) running on port ${SOURCE_PORT}`);
});


// ==========================================
// PART 2: MAIN API (The Retrofit Gateway)
// Port 3000 - No changes needed logic-wise, 
// just forwarding to Source API
// ==========================================
const mainApp = express();
mainApp.use(bodyParser.json());

// 1. GET Config
mainApp.get('/v1/terminal/:mid/:tid/integrated-mode-config', async (req, res) => {
    try {
        const response = await axios.post(`${SOURCE_URL}/internal/config`, { 
            mid: req.params.mid, 
            tid: req.params.tid 
        });
        res.json(response.data);
    } catch (e) { res.status(500).send(e.message); }
});

// 2. GET Check Void
mainApp.get('/v1/terminal/:mid/:tid/allow-void', async (req, res) => {
    try {
        const response = await axios.post(`${SOURCE_URL}/internal/check-void`, { 
            mid: req.params.mid, 
            tid: req.params.tid, 
            invoiceNumber: req.query.invoiceNumber 
        });
        res.json(response.data);
    } catch (e) { res.status(500).send(e.message); }
});

// 3. POST Sale
mainApp.post('/v1/sale-request', async (req, res) => {
    try {
        const response = await axios.post(`${SOURCE_URL}/internal/sale`, req.body);
        res.json(response.data);
    } catch (e) { res.status(500).send(e.message); }
});

// 4. POST Deploy
mainApp.post('/:terminalSNo/deploy', async (req, res) => {
    try {
        const response = await axios.post(`${SOURCE_URL}/internal/deploy`, { 
            terminalSNo: req.params.terminalSNo, 
            ...req.body 
        });
        res.json(response.data);
    } catch (e) { res.status(500).send(e.message); }
});

// 5. OTP Routes
mainApp.post('/verification/:workflowId/dispatch', async (req, res) => {
    try {
        const response = await axios.post(`${SOURCE_URL}/internal/otp/send`, { 
            workflowId: req.params.workflowId, 
            ...req.body 
        });
        res.json(response.data);
    } catch (e) { res.status(500).send(e.message); }
});

mainApp.post('/verification/:workflowId/verify', async (req, res) => {
    try {
        const response = await axios.post(`${SOURCE_URL}/internal/otp/verify`, { 
            workflowId: req.params.workflowId, 
            ...req.body 
        });
        res.json(response.data);
    } catch (e) { res.status(500).send(e.message); }
});

mainApp.listen(MAIN_PORT, () => {
    console.log(`ðŸš€ Main API (Android Gateway) running on port ${MAIN_PORT}`);
});